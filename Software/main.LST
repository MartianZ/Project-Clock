C51 COMPILER V9.00   MAIN                                                                  01/28/2013 15:54:21 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <STC_NEW_8051.h>
   2          #include <INTRINS.h>
   3          #include "delay.h"
   4          #include "DS12C887.h"
   5          #include "DS18B20.h"
   6          #include "EEPROM.h"
   7          sbit H1 = P0 ^ 0;
   8          sbit H2 = P0 ^ 1;
   9          sbit H3 = P0 ^ 2;
  10          sbit H4 = P0 ^ 3;
  11          sbit H5 = P0 ^ 4;
  12          sbit H6 = P0 ^ 5;
  13          sbit H7 = P0 ^ 6;
  14          
  15          sbit BEEP = P4 ^ 3;
  16          
  17          sbit INT0 = P3^2;
  18          sbit INT1 = P3^3;
  19          
  20          sbit HC595_DATA = P2 ^ 2;
  21          sbit HC595_STCP = P2 ^ 1;
  22          sbit HC595_SHCP = P2 ^ 0;
  23          
  24          volatile unsigned char line = 1;
  25          volatile unsigned long line_data[7]; 
  26          volatile unsigned char busy = 0;
  27          volatile unsigned char menu1 = 0;
  28          volatile unsigned char menu2 = 0;
  29          
  30          volatile unsigned char brightness = 2;
  31          
  32          code unsigned char code_dark[7] = {0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F};
  33          
  34          code unsigned char code_aa[7] = {0x1F, 0x1F, 0x1F, 0x11, 0xE, 0x0, 0xE};
  35          code unsigned char code_pp[7] = {0x1F, 0x1F, 0x1F, 0x1, 0xE, 0x1, 0xF};
  36          code unsigned char code_0_1[7] = {0x0, 0x4, 0x4, 0x4, 0x4, 0x4, 0x0};
  37          code unsigned char code_1_1[7] = {0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19};
  38          code unsigned char code_2_1[7] = {0x10, 0x1C, 0x1C, 0x0, 0x7, 0x7, 0x0};
  39          code unsigned char code_3_1[7] = {0x0, 0x1C, 0x1C, 0x10, 0x1C, 0x1C, 0x0};
  40          code unsigned char code_4_1[7] = {0x4, 0x4, 0x4, 0x0, 0x1C, 0x1C, 0x1C};
  41          code unsigned char code_5_1[7] = {0x1, 0x7, 0x7, 0x0, 0x1C, 0x1C, 0x0};
  42          code unsigned char code_6_1[7] = {0x1, 0x7, 0x7, 0x0, 0x4, 0x4, 0x0};
  43          code unsigned char code_7_1[7] = {0x0, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C};
  44          code unsigned char code_8_1[7] = {0x0, 0x4, 0x4, 0x0, 0x4, 0x4, 0x0};
  45          code unsigned char code_9_1[7] = {0x0, 0x4, 0x4, 0x0, 0x1C, 0x1C, 0x10};
  46          code unsigned char code_dot_1[7] = {0x1F, 0x13, 0x13, 0x1F, 0x13, 0x13, 0x1F};
  47          code unsigned char code_dot_2[7] = {0x1F, 0x1F, 0x13, 0x13, 0x13, 0x1F, 0x1F};
  48          code unsigned char code_dot_3[7] = {0x1F, 0x1F, 0x1F, 0x13, 0x1F, 0x1F, 0x1F};
  49          code unsigned char code_num[][7] = {{0x0, 0x4, 0x4, 0x4, 0x4, 0x4, 0x0}, {0x19, 0x19, 0x19, 0x19, 0x19, 0x
             -19, 0x19}, {0x10, 0x1C, 0x1C, 0x0, 0x7, 0x7, 0x0},
  50                            {0x0, 0x1C, 0x1C, 0x10, 0x1C, 0x1C, 0x0}, {0x4, 0x4, 0x4, 0x0, 0x1C, 0x1C, 0x1C}, {0x1, 0x7, 0x7, 0x0,
             - 0x1C, 0x1C, 0x0}, {0x1, 0x7, 0x7, 0x0, 0x4, 0x4, 0x0}, {0x0, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C},
  51                            {0x0, 0x4, 0x4, 0x0, 0x4, 0x4, 0x0}, {0x0, 0x4, 0x4, 0x0, 0x1C, 0x1C, 0x10}};   
  52          
  53          code unsigned char code_H[7] = {0xE, 0xE, 0xE, 0x0, 0xE, 0xE, 0xE};
C51 COMPILER V9.00   MAIN                                                                  01/28/2013 15:54:21 PAGE 2   

  54          code unsigned char code_M[7] = {0xE, 0x4, 0xA, 0xA, 0xE, 0xE, 0xE};
  55          code unsigned char code_S[7] = {0x10, 0xF, 0xF, 0x11, 0x1E, 0x1E, 0x1};
  56          code unsigned char code_Y[7] = {0xE, 0xE, 0x15, 0x1B, 0x1B, 0x1B, 0x1B};
  57          code unsigned char code_D[7] = {0x3, 0xD, 0xE, 0xE, 0xE, 0xD, 0x3};
  58          code unsigned char code_colon[7] = {0x1F, 0x1F, 0x1F, 0x1B, 0x1F, 0x1B, 0x1F};
  59          code unsigned char code_small_dot[7] = {0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x13, 0x13};
  60          code unsigned char code_celsius[7]      = {0x7, 0x7, 0x18, 0x17, 0x17, 0x17, 0x18};
  61          code unsigned char code_P[7] = {0x1, 0xE, 0xE, 0x1, 0xF, 0xF, 0xF};
  62          code unsigned char code_B[7] = {0x1, 0xE, 0xE, 0x0, 0xE, 0xE, 0x1};
  63          code unsigned char code_O[7] = {0x11, 0xE, 0xE, 0xE, 0xE, 0xE, 0x11};
  64          code unsigned char code_E[7] = {0x0, 0xF, 0xF, 0x0, 0xF, 0xF, 0x0}; 
  65          code unsigned char code_T[7] = {0x0, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B};
  66          
  67          code unsigned char code_oo[7] = {0x1F, 0x1F, 0x11, 0xE, 0xE, 0xE, 0x11};
  68          code unsigned char code_nn[7] = {0x1F, 0x1F, 0x9, 0x6, 0xE, 0xE, 0xE};
  69          code unsigned char code_yy[7] = {0x1F, 0x1F, 0xE, 0x15, 0x1B, 0x1B, 0x1B};
  70          code unsigned char code_dash[7] = {0x1F, 0x1F, 0x1F, 0x11, 0x1F, 0x1F, 0x1F};
  71          
  72          code unsigned char code_uu[7] = {0x1F, 0x1F, 0xE, 0xE, 0xE, 0xC, 0x12};
  73          code unsigned char code_ee[7] = {0x1F, 0x1F, 0x11, 0xE, 0x0, 0xF, 0x11};
  74          code unsigned char code_ss[7] = {0x1F, 0x1F, 0x10, 0xF, 0x11, 0x1E, 0x1};
  75          code unsigned char code_W[7] = {0xE, 0xE, 0xE, 0xA, 0xA, 0x4, 0xE};
  76          code unsigned char code_dd[7] = {0x1E, 0x1E, 0x12, 0xC, 0xE, 0xE, 0x10};
  77          code unsigned char code_hh[7] = {0xF, 0xF, 0x9, 0x6, 0xE, 0xE, 0xE};
  78          code unsigned char code_rr[7] = {0x1F, 0x1F, 0xC, 0xB, 0x7, 0xF, 0xF};
  79          code unsigned char code_F[7] = {0x0, 0xF, 0xF, 0x0, 0xF, 0xF, 0xF};
  80          code unsigned char code_ii[7] = {0x1F, 0x1F, 0x1B, 0x1F, 0x1B, 0x1B, 0x1B};
  81          code unsigned char code_tt[7] = {0x1F, 0x1F, 0x1F, 0x1B, 0x0, 0x1B, 0x18};
  82            
  83             
  84          
  85          void Timer0Init(void)
  86          {
  87   1              AUXR |= 0x7F;   //12T
  88   1              TMOD &= 0x01;
  89   1              TL0 = 0xFF;
  90   1              TH0 = 0xFF;
  91   1              TF0 = 0;        
  92   1              TR0 = 1;
  93   1              ET0 = 1;
  94   1      }
  95          
  96          void IntInit(void)
  97          {
  98   1              IT1 = 1;
  99   1              EX1 = 1;
 100   1              IT0 = 1;
 101   1              EX0 = 1;
 102   1      }
 103          
 104          void DynamicDisplay6(unsigned char *a, unsigned char *b, unsigned char *c, unsigned char *d, unsigned char
             - *e, unsigned char *f)
 105          {
 106   1              unsigned char i,j;
 107   1              for (i=1; i<=32; i++)
 108   1              {
 109   2                      for (j=0; j<7; j++)
 110   2                      {
 111   3                               line_data[j] = line_data[j] << 1;
 112   3                               if (i <= 5) line_data[j] |= (unsigned long)a[j] >> (5-i) & 1;
 113   3                               else if (i <= 10) line_data[j] |= (unsigned long)b[j] >> (10-i) & 1;
 114   3                               else if (i <= 15) line_data[j] |= (unsigned long)c[j] >> (15-i) & 1;
C51 COMPILER V9.00   MAIN                                                                  01/28/2013 15:54:21 PAGE 3   

 115   3                               else if (i <= 20) line_data[j] |= (unsigned long)d[j] >> (20-i) & 1;
 116   3                               else if (i <= 25) line_data[j] |= (unsigned long)e[j] >> (25-i) & 1;
 117   3                               else if (i <= 30) line_data[j] |= (unsigned long)f[j] >> (30-i) & 1;
 118   3                               Delay1ms();
 119   3                      }
 120   2              }
 121   1      }
 122          
 123          void Display6(unsigned char *a, unsigned char *b, unsigned char *c, unsigned char *d, unsigned char *e, un
             -signed char *f, unsigned char dynamic)
 124          {
 125   1              if (!dynamic)
 126   1              {
 127   2                      unsigned char i;
 128   2                      for (i=0; i<7; i++) 
 129   2                              line_data[i] = ((unsigned long)a[i] << 27) | ((unsigned long)b[i] << 22) | ((unsigned long)c[i] << 17) 
             -| ((unsigned long)d[i] << 12) | ((unsigned long)e[i] << 7) | ((unsigned long)f[i] << 2);      
 130   2              } else {
 131   2                      DynamicDisplay6(a,b,c,d,e,f);
 132   2              }
 133   1      }
 134          
 135          /*
 136          void DisplayPos(unsigned char *a, unsigned char pos)
 137          {
 138                  unsigned char i;
 139                  for (i=0; i<7; i++)
 140                  {
 141                          line_data[i] &= ~(unsigned long)0x1F << ((6-pos) * 5 + 2);
 142                          line_data[i] |= (unsigned long)a[i] << ((6-pos) * 5 + 2);       
 143                  }
 144          }
 145          */
 146          
 147          void ADCInit()
 148          {
 149   1              P1ASF = 0x80;
 150   1              AUXR1 = 0x04;
 151   1              ADC_CONTR = 0xEF;
 152   1      
 153   1              _nop_(); _nop_(); _nop_(); _nop_(); 
 154   1              PADC = 1;
 155   1              EADC = 1;       
 156   1      }
 157          
 158          unsigned char getMaxDay(unsigned int YYYY, unsigned char MON)
 159          {
 160   1              switch (MON)
 161   1          {
 162   2          case 1:
 163   2          case 3:
 164   2          case 5:
 165   2          case 7:
 166   2          case 8:
 167   2          case 10:
 168   2          case 12:return 31;
 169   2          case 4:
 170   2          case 6:
 171   2          case 9:
 172   2          case 11:return 30;
 173   2          case 2:             
 174   2              if (YYYY%400==0 || (YYYY%100!=0 && YYYY%4==0))
C51 COMPILER V9.00   MAIN                                                                  01/28/2013 15:54:21 PAGE 4   

 175   2                  return 29;
 176   2                      else
 177   2                              return 28; 
 178   2          default:    return 0;
 179   2          }
 180   1      }
 181          
 182          unsigned char getWeek(unsigned int YYYY, unsigned char MON, unsigned char DAY)
 183          {
 184   1              unsigned char y,m;
 185   1              y = ((YYYY % 100) / 4 + (YYYY % 100)) % 7;
 186   1              switch (MON)
 187   1              {
 188   2                      case 2:
 189   2                      case 3:
 190   2                      case 11: m = 2; break;
 191   2                      case 5: m = 0; break;
 192   2                      case 8: m = 1; break;
 193   2                      case 6: m = 3; break;
 194   2                      case 9:
 195   2                      case 12: m = 4; break;
 196   2                      case 4:
 197   2                      case 7: m = 5; break;
 198   2                      case 1:
 199   2                      case 10: m = 6; break;
 200   2              }
 201   1              if (YYYY % 400 == 0 || (YYYY%100!=0 && YYYY%4==0))
 202   1              {
 203   2                      if (MON == 2) m = 1;
 204   2                      if (MON == 1) m = 5;
 205   2              }
 206   1              return ((y + m + DAY) % 7);
 207   1      }
 208          
 209          void main()
 210          {       
 211   1              unsigned char i,HH,MM,SS,MON,DAY,m1 = 0,m2 = 0,mode,dynamic = 0,is24 = 0, enableBEEP = 1,WEEK;
 212   1              unsigned int YYYY,w,ww = 0;
 213   1      
 214   1      
 215   1              IntInit();
 216   1              Timer0Init();
 217   1              DS12887_Init();
 218   1              ADCInit();
 219   1      
 220   1              WDT_CONTR = 0x3E;
 221   1      
 222   1              PX0 = 0;
 223   1              PX1 = 0;
 224   1              PT0 = 1;
 225   1      
 226   1              P0 = 0xFF;
 227   1              BEEP = 1;
 228   1      
 229   1              is24 = IapReadByte(0);
 230   1              enableBEEP = IapReadByte(1);
 231   1      
 232   1              for (i=0; i<30; i++)
 233   1              {
 234   2                      HC595_DATA = 1;
 235   2                      HC595_SHCP = 0;
 236   2                      HC595_SHCP = 1; 
C51 COMPILER V9.00   MAIN                                                                  01/28/2013 15:54:21 PAGE 5   

 237   2              }
 238   1      
 239   1              HC595_STCP = 0;
 240   1              HC595_STCP = 1;
 241   1              
 242   1              
 243   1              EA = 1;
 244   1      
 245   1      
 246   1              while (1)
 247   1              {
 248   2                      //Display6(code_num[ADCResult / 10000], code_num[ADCResult % 10000 / 1000], code_num[ADCResult % 1000 /1
             -00], code_num[ADCResult % 100 /10], code_num[ADCResult % 10], code_small_dot, 0);
 249   2                      //Delayx10ms(255); 
 250   2                      
 251   2      
 252   2                      WDT_CONTR = 0x3E;
 253   2                      if (menu2 == 0 &&  menu1 == 0) ADC_CONTR = 0xEF; else { brightness = 2; }
 254   2                      HH = DS12887_Read(DS_HOR) & 0x7F;
 255   2                      HH = (HH >> 4) * 10 + (HH & 0x0F);
 256   2                      MM = DS12887_Read(DS_MIN);
 257   2      
 258   2      
 259   2                      if (menu1 == 0 && menu2 == 0)
 260   2                      {       
 261   3                              if (!is24)
 262   3                              {
 263   4                                      if (HH >= 12)
 264   4                                      {
 265   5                                              if (HH > 12) HH -= 12;
 266   5                                              Display6(code_pp, code_num[HH / 10], code_num[HH % 10], code_dot_1, code_num[MM >> 4], code_num[MM & 
             -0x0F],0);
 267   5                                              if (brightness == 0) Delayx10ms(2); else Delayx10ms(5);
 268   5                                              Display6(code_pp, code_num[HH / 10], code_num[HH % 10], code_dot_2, code_num[MM >> 4], code_num[MM & 
             -0x0F],0);
 269   5                                              if (brightness == 0) Delayx10ms(2); else Delayx10ms(5);
 270   5                                              Display6(code_pp, code_num[HH / 10], code_num[HH % 10], code_dot_3, code_num[MM >> 4], code_num[MM & 
             -0x0F],0);
 271   5                                              if (brightness == 0) Delayx10ms(2); else Delayx10ms(5);
 272   5                                              Display6(code_pp, code_num[HH / 10], code_num[HH % 10], code_dot_2, code_num[MM >> 4], code_num[MM & 
             -0x0F],0);
 273   5                                              if (brightness == 0) Delayx10ms(2); else Delayx10ms(5);
 274   5                                              Display6(code_pp, code_num[HH / 10], code_num[HH % 10], code_dot_1, code_num[MM >> 4], code_num[MM & 
             -0x0F],0);
 275   5                                      
 276   5                                      } else {
 277   5                                              Display6(code_aa, code_num[HH / 10], code_num[HH % 10], code_dot_1, code_num[MM >> 4], code_num[MM & 
             -0x0F],0);
 278   5                                              if (brightness == 0) Delayx10ms(2); else Delayx10ms(5);
 279   5                                              Display6(code_aa, code_num[HH / 10], code_num[HH % 10], code_dot_2, code_num[MM >> 4], code_num[MM & 
             -0x0F],0);
 280   5                                              if (brightness == 0) Delayx10ms(2); else Delayx10ms(5);
 281   5                                              Display6(code_aa, code_num[HH / 10], code_num[HH % 10], code_dot_3, code_num[MM >> 4], code_num[MM & 
             -0x0F],0);
 282   5                                              if (brightness == 0) Delayx10ms(2); else Delayx10ms(5);
 283   5                                              Display6(code_aa, code_num[HH / 10], code_num[HH % 10], code_dot_2, code_num[MM >> 4], code_num[MM & 
             -0x0F],0);
 284   5                                              if (brightness == 0) Delayx10ms(2); else Delayx10ms(5);
 285   5                                              Display6(code_aa, code_num[HH / 10], code_num[HH % 10], code_dot_1, code_num[MM >> 4], code_num[MM & 
             -0x0F],0);
 286   5                                      }
 287   4                              } else {
C51 COMPILER V9.00   MAIN                                                                  01/28/2013 15:54:21 PAGE 6   

 288   4                                      Display6(code_dark, code_num[HH / 10], code_num[HH % 10], code_dot_1, code_num[MM >> 4], code_num[MM &
             - 0x0F],0);
 289   4                                      if (brightness == 0) Delayx10ms(2); else Delayx10ms(5);
 290   4                                      Display6(code_dark, code_num[HH / 10], code_num[HH % 10], code_dot_2, code_num[MM >> 4], code_num[MM &
             - 0x0F],0);
 291   4                                      if (brightness == 0) Delayx10ms(2); else Delayx10ms(5);
 292   4                                      Display6(code_dark, code_num[HH / 10], code_num[HH % 10], code_dot_3, code_num[MM >> 4], code_num[MM &
             - 0x0F],0);
 293   4                                      if (brightness == 0) Delayx10ms(2); else Delayx10ms(5);
 294   4                                      Display6(code_dark, code_num[HH / 10], code_num[HH % 10], code_dot_2, code_num[MM >> 4], code_num[MM &
             - 0x0F],0);
 295   4                                      if (brightness == 0) Delayx10ms(2); else Delayx10ms(5);
 296   4                                      Display6(code_dark, code_num[HH / 10], code_num[HH % 10], code_dot_1, code_num[MM >> 4], code_num[MM &
             - 0x0F],0);        
 297   4                              }
 298   3      
 299   3                      } 
 300   2                      else if (menu1)
 301   2                      {       
 302   3                              if (menu1 != m1)
 303   3                              {
 304   4                                      if (enableBEEP) BEEP = 0;
 305   4                                      Delayx10ms(10);
 306   4                                      m1 = menu1;
 307   4                                      mode++; dynamic = 1;
 308   4                                      BEEP = 1;
 309   4                              } else {
 310   4                                      Delayx10ms(5);
 311   4                              }
 312   3      
 313   3                              //设置星期
 314   3                              YYYY = BCD_DEC(DS12887_Read(DS_Y_S)) * 100 + BCD_DEC(DS12887_Read(DS_YER));
 315   3                              MON = BCD_DEC(DS12887_Read(DS_MON));
 316   3                              DAY = BCD_DEC(DS12887_Read(DS_DAY));
 317   3      
 318   3                              WEEK = getWeek(YYYY, MON, DAY);
 319   3                              DS12887_Write(DS_WEK, DEC_BCD(WEEK));
 320   3      
 321   3                              //首先设置时间：
 322   3                              if (mode == 1) //小时
 323   3                              {
 324   4                                      HH = BCD_DEC(DS12887_Read(DS_HOR));
 325   4                                      Display6(code_H, code_H, code_colon, code_dark, code_num[HH / 10], code_num[HH % 10], dynamic);
 326   4                                      dynamic = 0;
 327   4                                      Delay10ms();
 328   4                                      if (menu2 != m2)
 329   4                                      {
 330   5                                              if (enableBEEP) BEEP = 0;
 331   5                                          Delayx10ms(7);
 332   5                                              m2 = menu2;
 333   5                                              if (++HH > 23) HH = 0;
 334   5                                              DS12887_Write(DS_HOR, DEC_BCD(HH));
 335   5                                              BEEP = 1;       
 336   5                                      }       
 337   4                              }
 338   3                              if (mode == 2) //分钟
 339   3                              {
 340   4                                      MM = BCD_DEC(DS12887_Read(DS_MIN));
 341   4      
 342   4                                      Display6(code_M, code_M, code_colon, code_dark, code_num[MM / 10], code_num[MM % 10], dynamic);
 343   4                                      dynamic = 0;
 344   4                                      Delay10ms();
C51 COMPILER V9.00   MAIN                                                                  01/28/2013 15:54:21 PAGE 7   

 345   4                                      if (menu2 != m2)
 346   4                                      {
 347   5                                              if (enableBEEP) BEEP = 0;
 348   5                                              Delayx10ms(7);
 349   5                                              m2 = menu2;
 350   5                                              if (++MM > 59) MM = 0;
 351   5                                              DS12887_Write(DS_MIN, DEC_BCD(MM));     
 352   5                                              BEEP = 1;
 353   5                                                      
 354   5                                      }
 355   4                              }
 356   3                              if (mode == 3) //秒
 357   3                              {
 358   4                                      SS = BCD_DEC(DS12887_Read(DS_SEC));
 359   4      
 360   4                                      Display6(code_S, code_S, code_colon, code_dark, code_num[SS / 10], code_num[SS % 10], dynamic);
 361   4                                      dynamic = 0;
 362   4                                      Delay10ms();
 363   4                                      if (menu2 != m2)
 364   4                                      {
 365   5                                              if (enableBEEP) BEEP = 0;
 366   5                                              Delayx10ms(7);
 367   5                                              m2 = menu2;     
 368   5                                              if (SS > 0) SS--;
 369   5                                              DS12887_Write(DS_SEC, DEC_BCD(SS));
 370   5                                              BEEP = 1;       
 371   5                                      }       
 372   4                              }
 373   3      
 374   3                              if (mode == 4) //年
 375   3                              {
 376   4                                      Display6(code_Y, code_colon, code_num[YYYY / 1000], code_num[YYYY / 100 % 10], code_num[YYYY / 10 % 10
             -], code_num[YYYY % 10], dynamic);
 377   4                                      dynamic = 0;
 378   4                                      Delay10ms();
 379   4                                      if (menu2 != m2)
 380   4                                      {
 381   5                                              if (enableBEEP) BEEP = 0;
 382   5                                              Delayx10ms(7);
 383   5                                              m2 = menu2;     
 384   5                                              if (++YYYY > 2100) YYYY = 2013;
 385   5                                              if (DAY > getMaxDay(YYYY, MON)) DAY = 1;
 386   5                                              DS12887_Write(DS_Y_S, DEC_BCD((YYYY / 100)));
 387   5                                              DS12887_Write(DS_YER, DEC_BCD((YYYY % 100)));
 388   5                                              DS12887_Write(DS_DAY, DEC_BCD(DAY));
 389   5                                              BEEP = 1;       
 390   5                                      }       
 391   4                              }
 392   3      
 393   3                              if (mode == 5) //月
 394   3                              {
 395   4      
 396   4                                      Display6(code_M, code_oo, code_nn, code_colon, code_num[MON / 10], code_num[MON % 10], dynamic);
 397   4                                      dynamic = 0;
 398   4                                      Delay10ms();
 399   4                                      if (menu2 != m2)
 400   4                                      {
 401   5                                              if (enableBEEP) BEEP = 0;
 402   5                                          Delayx10ms(7);
 403   5                                              m2 = menu2;     
 404   5                                              if (++MON > 12) MON = 1;
 405   5                                              if (DAY > getMaxDay(YYYY, MON)) DAY = 1;
C51 COMPILER V9.00   MAIN                                                                  01/28/2013 15:54:21 PAGE 8   

 406   5                                              DS12887_Write(DS_MON, DEC_BCD(MON));
 407   5                                              DS12887_Write(DS_DAY, DEC_BCD(DAY));
 408   5                                              BEEP = 1;       
 409   5                                      }       
 410   4                              }
 411   3      
 412   3                              if (mode == 6) //日
 413   3                              {
 414   4                                      Display6(code_D, code_aa , code_yy, code_colon, code_num[DAY / 10], code_num[DAY % 10], dynamic);
 415   4                                      dynamic = 0;
 416   4                                      Delay10ms();
 417   4                                      if (menu2 != m2)
 418   4                                      {
 419   5                                              if (enableBEEP) BEEP = 0;
 420   5                                              Delayx10ms(7);
 421   5                                              m2 = menu2;     
 422   5                                              if (++DAY > getMaxDay(YYYY, MON)) DAY = 1;
 423   5                                              DS12887_Write(DS_DAY, DEC_BCD(DAY));
 424   5                                              BEEP = 1;       
 425   5                                      }       
 426   4                              }
 427   3      
 428   3                              if (mode == 7) //12/24
 429   3                              {
 430   4                                      if (is24)
 431   4                                      {
 432   5                                              Display6(code_dark, code_dark, code_dark, code_num[2], code_num[4], code_H, dynamic);
 433   5                                      } else {
 434   5                                              Display6(code_dark, code_dark, code_dark, code_num[1], code_num[2], code_H, dynamic);
 435   5                                      }
 436   4                                      dynamic = 0;
 437   4                                      Delay10ms();
 438   4                                      if (menu2 != m2)
 439   4                                      {
 440   5                                              if (enableBEEP) BEEP = 0;
 441   5                                              Delayx10ms(7);
 442   5                                              m2 = menu2;     
 443   5                                              if(is24) is24 = 0; else is24 = 1;
 444   5                                              IapEraseSector(0);
 445   5                                              IapProgramByte(0, is24);
 446   5                                              IapProgramByte(1, enableBEEP);                                  
 447   5                                              BEEP = 1;       
 448   5                                      }       
 449   4                              }
 450   3      
 451   3                              if (mode == 8) //Enable Beep
 452   3                              {
 453   4                                      if (enableBEEP)
 454   4                                      {
 455   5                                              Display6(code_B, code_E, code_E, code_P, code_colon, code_num[1], dynamic);
 456   5                                      } else {
 457   5                                              Display6(code_B, code_E, code_E, code_P, code_colon, code_num[0], dynamic);
 458   5                                      }
 459   4                                      dynamic = 0;
 460   4                                      Delay10ms();
 461   4                                      if (menu2 != m2)
 462   4                                      {
 463   5                                              if (enableBEEP) BEEP = 0;
 464   5                                              Delayx10ms(7);
 465   5                                              m2 = menu2;     
 466   5                                              if(enableBEEP) enableBEEP = 0; else enableBEEP = 1;
 467   5                                              IapEraseSector(0);
C51 COMPILER V9.00   MAIN                                                                  01/28/2013 15:54:21 PAGE 9   

 468   5                                              IapProgramByte(0, is24);
 469   5                                              IapProgramByte(1, enableBEEP);                                  
 470   5                                              BEEP = 1;       
 471   5                                      }       
 472   4                              }
 473   3                              
 474   3      
 475   3                              if (mode > 8) 
 476   3                              {
 477   4                                      menu1 = 0;
 478   4                                      menu2 = 0;
 479   4                                      m1 = 0;
 480   4                                      m2 = 0;
 481   4                                      mode = 0;
 482   4                              }
 483   3      
 484   3      
 485   3                                                      
 486   3                      } else if (menu2)
 487   2                      {
 488   3                              
 489   3      
 490   3                              if (menu2 != m2)
 491   3                              {
 492   4                                      if (enableBEEP) BEEP = 0;
 493   4                                      Delayx10ms(10);
 494   4                                      m2 = menu2;
 495   4                                      mode++; dynamic = 1;
 496   4                                      BEEP = 1;
 497   4                              };
 498   3      
 499   3      
 500   3                              YYYY = BCD_DEC(DS12887_Read(DS_Y_S)) * 100 + BCD_DEC(DS12887_Read(DS_YER));
 501   3                              MON = BCD_DEC(DS12887_Read(DS_MON));
 502   3                              DAY = BCD_DEC(DS12887_Read(DS_DAY));
 503   3                              WEEK = BCD_DEC(DS12887_Read(DS_WEK));
 504   3      
 505   3                              if (mode == 1)
 506   3                              {
 507   4                                      //温度
 508   4                                      
 509   4                                      w = DS18B20_Read();
 510   4                                      if (!ww || w < ww || (w % 1000 - ww % 1000 <= 20) || ww % 1000 > 400) ww = w;
 511   4      
 512   4                                      Display6(code_dark, code_num[(ww % 1000) / 100], code_num[(ww % 100) / 10], code_small_dot, code_num[w
             -w % 10], code_celsius, dynamic);
 513   4                                      dynamic = 0;
 514   4                                      Delayx10ms(10);
 515   4                              }
 516   3      
 517   3                              if (mode == 2)
 518   3                              {
 519   4                                      //WEEK
 520   4                                      switch(WEEK)
 521   4                                      {
 522   5                                              case 1:Display6(code_dark, code_dark, code_M, code_oo, code_nn, code_small_dot, dynamic); break;        
 523   5                                              case 2:Display6(code_dark, code_T, code_uu, code_ee, code_ss, code_small_dot, dynamic); break;  
 524   5                                              case 3:Display6(code_dark, code_dark, code_W, code_ee, code_dd, code_small_dot, dynamic); break;        
 525   5                                              case 4:Display6(code_dark, code_T, code_hh, code_uu, code_rr, code_small_dot, dynamic); break;  
 526   5                                              case 5:Display6(code_dark, code_dark, code_F, code_rr, code_ii, code_small_dot, dynamic); break;        
 527   5                                              case 6:Display6(code_dark, code_dark, code_S, code_aa, code_tt, code_small_dot, dynamic); break;        
 528   5                                              case 0:Display6(code_dark, code_dark, code_S, code_uu, code_nn, code_small_dot, dynamic); break;        
C51 COMPILER V9.00   MAIN                                                                  01/28/2013 15:54:21 PAGE 10  

 529   5                                      }
 530   4                                      
 531   4                                      dynamic = 0;
 532   4                                      Delayx10ms(4);
 533   4                              }
 534   3      
 535   3                              if (mode == 3)
 536   3                              {
 537   4                                      //月日
 538   4                                      Display6(code_dark, code_num[MON / 10], code_num[MON % 10], code_dash, code_num[DAY / 10], code_num[DA
             -Y % 10], dynamic);
 539   4                                      dynamic = 0;
 540   4                                      Delayx10ms(4);
 541   4      
 542   4                              }
 543   3      
 544   3                              if (mode == 4)
 545   3                              {
 546   4                                      //年
 547   4                                      Display6(code_dark, code_dark, code_num[YYYY / 1000], code_num[YYYY / 100 % 10], code_num[YYYY / 10 % 
             -10], code_num[YYYY % 10], dynamic);
 548   4                                      dynamic = 0;
 549   4                                      Delayx10ms(4);
 550   4                              }
 551   3      
 552   3      
 553   3      
 554   3                              if (mode > 4) 
 555   3                              {
 556   4                                      menu1 = 0;
 557   4                                      menu2 = 0;
 558   4                                      m1 = 0;
 559   4                                      m2 = 0;
 560   4                                      mode = 0;
 561   4                                      ww = 0;
 562   4                              }
 563   3                              
 564   3                      }  
 565   2      
 566   2      
 567   2                      for (i=0; i<=25; i++)
 568   2                      {
 569   3                              if (brightness == 0) Delayx10ms(1); else Delayx10ms(2);
 570   3                              WDT_CONTR = 0x3E;
 571   3                              if (menu1 || menu2) break;
 572   3                      }
 573   2                              
 574   2              }
 575   1      }
 576          
 577          void int0_interrupt (void) interrupt 0
 578          {
 579   1              busy = 1;
 580   1              if (++menu1 > 200) menu1 = 1;
 581   1              busy = 0;
 582   1              
 583   1      }
 584          
 585          void int1_interrupt (void) interrupt 2
 586          {
 587   1          busy = 1;
 588   1              if (++menu2 > 200) menu2 = 1;
C51 COMPILER V9.00   MAIN                                                                  01/28/2013 15:54:21 PAGE 11  

 589   1              busy = 0;       
 590   1      }
 591          
 592          void time0_interrupt (void) interrupt 1 
 593          {
 594   1      
 595   1              unsigned char i;
 596   1              P0 = 0xFF;
 597   1      
 598   1              for (i=0; i<30; i++)
 599   1              {
 600   2                      HC595_DATA = ((line_data[line-1] << i) & 0x80000000) == 0x80000000;     
 601   2                      HC595_SHCP = 0;
 602   2                      HC595_SHCP = 1; 
 603   2              }
 604   1         
 605   1              HC595_STCP = 0;
 606   1              HC595_STCP = 1;
 607   1      
 608   1          switch(line)
 609   1              {
 610   2                      case 1:H1=0; break;
 611   2                      case 2:H2=0; break;
 612   2                      case 3:H3=0; break;
 613   2                      case 4:H4=0; break;
 614   2                      case 5:H5=0; break;
 615   2                      case 6:H6=0; break;
 616   2                      case 7:H7=0; break;
 617   2              }
 618   1              if (++line == 8) line = 1;
 619   1      
 620   1              if (brightness == 0)
 621   1              {
 622   2                      TL0 = 0xD7;     
 623   2                      TH0 = 0xFD;
 624   2              } else if (brightness == 1)
 625   1              {
 626   2                      TL0 = 0x33;     
 627   2                      TH0 = 0xE3;
 628   2              } else// if (brightness == 2)
 629   1              {
 630   2                      TL0 = 0x00;     
 631   2                      TH0 = 0xB8;
 632   2              }
 633   1      
 634   1      }
 635          
 636          void ADC_interrupt (void) interrupt 5
 637          {
 638   1          unsigned int ADCResult;
 639   1              ADC_CONTR = 0x0;        
 640   1              _nop_(); _nop_();_nop_();_nop_();_nop_();_nop_();
 641   1          ADCResult = ADC_RES * 256 + ADC_RESL;
 642   1          if (ADCResult > 950) brightness = 0;
 643   1              else if (ADCResult > 800) brightness = 1; else brightness = 2;
 644   1      
 645   1              //while(1);     
 646   1      
 647   1      }
 648          
 649          

C51 COMPILER V9.00   MAIN                                                                  01/28/2013 15:54:21 PAGE 12  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6868    ----
   CONSTANT SIZE    =    371    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     33      63
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
